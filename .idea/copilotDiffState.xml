<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/scala/Fish.scala">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/scala/Fish.scala" />
              <option name="originalContent" value="import scala.util.Random&#10;&#10;case class Fish(fX: Int, fY: Int, nTunas: Int, nSharks: Int) {&#10;&#10;}&#10;&#10;object Fish {&#10;  def randomPosition(screenWidth: Int, screenHeight: Int, nTunas: Int, nSharks: Int): Fish =&#10;    Fish(Random.nextInt(screenWidth), Random.nextInt(screenHeight), nTunas, nSharks)&#10;&#10;}&#10;" />
              <option name="updatedContent" value="import scalafx.scene.shape.Rectangle&#10;&#10;// Type alias pour les coordonnées&#10;type Coordinates = (Int, Int)&#10;&#10;// Trait abstrait représentant un poisson&#10;trait Fish {&#10;  def x: Int&#10;  def y: Int&#10;  def coordinates: Coordinates = (x, y)&#10;  def draw: Rectangle&#10;  def breedCounter: Int&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/scala/Main.scala">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/scala/Main.scala" />
              <option name="originalContent" value="import scalafx.animation.{KeyFrame, Timeline}&#10;import scalafx.application.JFXApp3&#10;import scalafx.application.JFXApp3.PrimaryStage&#10;import scalafx.beans.property.ObjectProperty&#10;import scalafx.scene.Scene&#10;import scalafx.stage.Screen&#10;import scalafx.util.Duration&#10;import scala.language.postfixOps&#10;&#10;object Main extends JFXApp3 {&#10;&#10;  private final val agentSize: Int      = 9&#10;  private final val numberOfTunas: Int  = 500&#10;  private final val numberOfSharks: Int = 50&#10;  private final val tunaBreed: Int      = 2&#10;  private final val sharkBreed: Int     = 9&#10;  private final val sharkEnergy: Int    = 3&#10;&#10;  override def start(): Unit = {&#10;    val (screenWidth, screenHeight) = (Screen.primary.visualBounds.width.toInt, Screen.primary.visualBounds.height.toInt)&#10;    val (boardWidth, boardHeight)   = (screenWidth / agentSize, screenHeight / agentSize)&#10;    &#10;    stage = new PrimaryStage {&#10;      title = &quot;Wator&quot;&#10;      width = boardWidth&#10;      height = boardHeight&#10;      scene = new Scene {&#10;        content = List.empty&#10;        List.onChange {&#10;          content = List.empty&#10;        }&#10;      }&#10;    }&#10;  &#10;    new Timeline {&#10;      keyFrames = List(&#10;        KeyFrame(&#10;          time = Duration(50),&#10;          onFinished = _ =&gt; {&#10;            // Update logic for tunas and sharks would go here&#10;          }&#10;        )&#10;      )&#10;      cycleCount = Timeline.Indefinite&#10;    }.play()&#10;    &#10;  }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import scalafx.animation.{KeyFrame, Timeline}&#10;import scalafx.application.JFXApp3&#10;import scalafx.application.JFXApp3.PrimaryStage&#10;import scalafx.beans.property.ObjectProperty&#10;import scalafx.scene.Scene&#10;import scalafx.stage.Screen&#10;import scalafx.util.Duration&#10;import scala.language.postfixOps&#10;&#10;object Main extends JFXApp3 {&#10;&#10;  private final val agentSize: Int      = 9&#10;  private final val numberOfTunas: Int  = 500&#10;  private final val numberOfSharks: Int = 50&#10;  private final val tunaBreed: Int      = 2&#10;  private final val sharkBreed: Int     = 9&#10;  private final val sharkEnergy: Int    = 3&#10;&#10;  override def start(): Unit = {&#10;    val (screenWidth, screenHeight) = (Screen.primary.visualBounds.width.toInt, Screen.primary.visualBounds.height.toInt)&#10;    val (boardWidth, boardHeight)   = (screenWidth / agentSize, screenHeight / agentSize)&#10;    &#10;    // Initialiser l'océan avec les poissons&#10;    val oceanProperty = ObjectProperty(&#10;      Ocean.initialize(&#10;        width = boardWidth,&#10;        height = boardHeight,&#10;        nTunas = numberOfTunas,&#10;        nSharks = numberOfSharks,&#10;        tunaBreedTime = tunaBreed,&#10;        sharkBreedTime = sharkBreed,&#10;        sharkEnergy = sharkEnergy&#10;      )&#10;    )&#10;    &#10;    stage = new PrimaryStage {&#10;      title = &quot;Wator&quot;&#10;      width = screenWidth&#10;      height = screenHeight&#10;      scene = new Scene {&#10;        content = oceanProperty.value.drawAll&#10;        &#10;        // Mettre à jour l'affichage quand l'océan change&#10;        oceanProperty.onChange { (_, _, newOcean) =&gt;&#10;          content = newOcean.drawAll&#10;        }&#10;      }&#10;    }&#10;  &#10;    new Timeline {&#10;      keyFrames = List(&#10;        KeyFrame(&#10;          time = Duration(50),&#10;          onFinished = _ =&gt; {&#10;            // TODO: Mettre à jour l'état de l'océan à chaque cycle&#10;            // oceanProperty.value = oceanProperty.value.update()&#10;          }&#10;        )&#10;      )&#10;      cycleCount = Timeline.Indefinite&#10;    }.play()&#10;    &#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/scala/Ocean.scala">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/scala/Ocean.scala" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="import scala.util.Random&#10;import scalafx.scene.shape.Rectangle&#10;&#10;// Type alias pour les coordonnées&#10;type Position = (Int, Int)&#10;&#10;// Case class immutable représentant l'océan&#10;case class Ocean(&#10;  width: Int,&#10;  height: Int,&#10;  tunas: List[Tuna],&#10;  sharks: List[Shark],&#10;  tunaBreedTime: Int,&#10;  sharkBreedTime: Int,&#10;  sharkInitialEnergy: Int&#10;) {&#10;  &#10;  // Obtenir toutes les positions occupées&#10;  private def occupiedPositions: Set[Position] = &#10;    (tunas.map(t =&gt; (t.x, t.y)) ++ sharks.map(s =&gt; (s.x, s.y))).toSet&#10;  &#10;  // Obtenir les positions des thons&#10;  private def tunaPositions: Map[Position, Tuna] = &#10;    tunas.map(t =&gt; (t.x, t.y) -&gt; t).toMap&#10;  &#10;  // Vérifier si une position est libre&#10;  private def isFree(x: Int, y: Int): Boolean = &#10;    !occupiedPositions.contains((x, y))&#10;  &#10;  // Obtenir les voisins selon le voisinage de Moore&#10;  private def mooreNeighbors(x: Int, y: Int): List[Position] = {&#10;    val directions = List(&#10;      (-1, -1), (-1, 0), (-1, 1),&#10;      (0, -1),           (0, 1),&#10;      (1, -1),  (1, 0),  (1, 1)&#10;    )&#10;    &#10;    directions.map { case (dx, dy) =&gt;&#10;      val newX = (x + dx + width) % width&#10;      val newY = (y + dy + height) % height&#10;      (newX, newY)&#10;    }&#10;  }&#10;  &#10;  // Obtenir les voisins libres&#10;  def freeNeighbors(x: Int, y: Int): List[Position] = &#10;    mooreNeighbors(x, y).filter { case (nx, ny) =&gt; isFree(nx, ny) }&#10;  &#10;  // Obtenir les voisins contenant des thons&#10;  def tunaNeighbors(x: Int, y: Int): List[Position] = &#10;    mooreNeighbors(x, y).filter(tunaPositions.contains)&#10;  &#10;  // Dessiner tous les poissons&#10;  def drawAll: List[Rectangle] = &#10;    tunas.map(_.draw) ++ sharks.map(_.draw)&#10;}&#10;&#10;object Ocean {&#10;  // Créer un océan initial avec des positions aléatoires&#10;  def initialize(&#10;    width: Int,&#10;    height: Int,&#10;    nTunas: Int,&#10;    nSharks: Int,&#10;    tunaBreedTime: Int,&#10;    sharkBreedTime: Int,&#10;    sharkEnergy: Int&#10;  ): Ocean = {&#10;    &#10;    // Générer des positions aléatoires uniques&#10;    def generateUniquePositions(count: Int, occupied: Set[Position]): List[Position] = {&#10;      if (count &lt;= 0) Nil&#10;      else {&#10;        val pos = (Random.nextInt(width), Random.nextInt(height))&#10;        if (occupied.contains(pos)) &#10;          generateUniquePositions(count, occupied)&#10;        else &#10;          pos :: generateUniquePositions(count - 1, occupied + pos)&#10;      }&#10;    }&#10;    &#10;    // Créer les thons&#10;    val tunaPositions = generateUniquePositions(nTunas, Set.empty)&#10;    val tunas = tunaPositions.map { case (x, y) =&gt; Tuna(x, y) }&#10;    &#10;    // Créer les requins&#10;    val sharkPositions = generateUniquePositions(nSharks, tunaPositions.toSet)&#10;    val sharks = sharkPositions.map { case (x, y) =&gt; Shark(x, y, 0, sharkEnergy) }&#10;    &#10;    Ocean(width, height, tunas, sharks, tunaBreedTime, sharkBreedTime, sharkEnergy)&#10;  }&#10;  &#10;  // Version alternative avec Random explicite pour les tests&#10;  def initializeWithSeed(&#10;    width: Int,&#10;    height: Int,&#10;    nTunas: Int,&#10;    nSharks: Int,&#10;    tunaBreedTime: Int,&#10;    sharkBreedTime: Int,&#10;    sharkEnergy: Int,&#10;    seed: Long&#10;  ): Ocean = {&#10;    val random = new Random(seed)&#10;    &#10;    def generateUniquePositions(count: Int, occupied: Set[Position]): List[Position] = {&#10;      if (count &lt;= 0) Nil&#10;      else {&#10;        val pos = (random.nextInt(width), random.nextInt(height))&#10;        if (occupied.contains(pos)) &#10;          generateUniquePositions(count, occupied)&#10;        else &#10;          pos :: generateUniquePositions(count - 1, occupied + pos)&#10;      }&#10;    }&#10;    &#10;    val tunaPositions = generateUniquePositions(nTunas, Set.empty)&#10;    val tunas = tunaPositions.map { case (x, y) =&gt; Tuna(x, y) }&#10;    &#10;    val sharkPositions = generateUniquePositions(nSharks, tunaPositions.toSet)&#10;    val sharks = sharkPositions.map { case (x, y) =&gt; Shark(x, y, 0, sharkEnergy) }&#10;    &#10;    Ocean(width, height, tunas, sharks, tunaBreedTime, sharkBreedTime, sharkEnergy)&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/scala/Shark.scala">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/scala/Shark.scala" />
              <option name="originalContent" value="import scalafx.scene.paint.Color&#10;import scalafx.scene.shape.Rectangle&#10;&#10;case class Shark(sBreed: Int, sEnergie: Int, sX: Int, sY: Int) {&#10;  def draw: Rectangle = {&#10;    new Rectangle {&#10;      x = sX&#10;      y = sY&#10;      width = 1&#10;      height = 1&#10;      fill = Color.Red&#10;    }&#10;  }&#10;}&#10;&#10;&#10;" />
              <option name="updatedContent" value="import scalafx.scene.paint.Color&#10;import scalafx.scene.shape.Rectangle&#10;&#10;case class Shark(x: Int, y: Int, breedCounter: Int = 0, energy: Int) extends Fish {&#10;  def draw: Rectangle = {&#10;    val rect = new Rectangle {&#10;      width = 1&#10;      height = 1&#10;      fill = Color.Red&#10;    }&#10;    rect.x = this.x&#10;    rect.y = this.y&#10;    rect&#10;  }&#10;&#10;  // Se déplacer vers de nouvelles coordonnées&#10;  def moveTo(newX: Int, newY: Int, ate: Boolean): Shark = {&#10;    val newEnergy = if (ate) energy + 1 else energy - 1&#10;    this.copy(x = newX, y = newY, breedCounter = breedCounter + 1, energy = newEnergy)&#10;  }&#10;&#10;  // Se reproduire (reset le compteur)&#10;  def breed: Shark = this.copy(breedCounter = 0)&#10;&#10;  // Vérifier si le requin est mort (énergie &lt;= 0)&#10;  def isDead: Boolean = energy &lt;= 0&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/scala/Tuna.scala">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/scala/Tuna.scala" />
              <option name="originalContent" value="import scalafx.scene.paint.Color&#10;import scalafx.scene.shape.Rectangle&#10;import scala.util.Random&#10;&#10;case class Tuna(tBreed: Int, tX: Int, tY: Int) {&#10;  def draw: Rectangle = {&#10;    new Rectangle {&#10;      x = tX&#10;      y = tY&#10;      width = 1&#10;      height = 1&#10;      fill = Color.Blue&#10;    }&#10;  }&#10;}&#10;&#10;object Tuna {&#10;  def randomDirection: Direction = Random.nextInt(8) match {&#10;    case 0 =&gt; Direction.NORTH&#10;    case 1 =&gt; Direction.SOUTH&#10;    case 2 =&gt; Direction.EAST&#10;    case 3 =&gt; Direction.WEST&#10;    case 4 =&gt; Direction.NORTHEAST&#10;    case 5 =&gt; Direction.NORTHWEST&#10;    case 6 =&gt; Direction.SOUTHEAST&#10;    case _ =&gt; Direction.SOUTHWEST&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import scalafx.scene.paint.Color&#10;import scalafx.scene.shape.Rectangle&#10;import scala.util.Random&#10;&#10;case class Tuna(x: Int, y: Int, breedCounter: Int = 0) extends Fish {&#10;  def draw: Rectangle = {&#10;    val rect = new Rectangle {&#10;      width = 1&#10;      height = 1&#10;      fill = Color.Blue&#10;    }&#10;    rect.x = this.x&#10;    rect.y = this.y&#10;    rect&#10;  }&#10;&#10;  // Incrémenter le compteur de reproduction&#10;  def incrementBreed: Tuna = this.copy(breedCounter = breedCounter + 1)&#10;&#10;  // Se déplacer vers de nouvelles coordonnées&#10;  def moveTo(newX: Int, newY: Int): Tuna = this.copy(x = newX, y = newY, breedCounter = breedCounter + 1)&#10;&#10;  // Se reproduire (reset le compteur)&#10;  def breed: Tuna = this.copy(breedCounter = 0)&#10;}&#10;&#10;object Tuna {&#10;  def randomDirection: Direction = Random.nextInt(8) match {&#10;    case 0 =&gt; Direction.NORTH&#10;    case 1 =&gt; Direction.SOUTH&#10;    case 2 =&gt; Direction.EAST&#10;    case 3 =&gt; Direction.WEST&#10;    case 4 =&gt; Direction.NORTHEAST&#10;    case 5 =&gt; Direction.NORTHWEST&#10;    case 6 =&gt; Direction.SOUTHEAST&#10;    case _ =&gt; Direction.SOUTHWEST&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>